commit 8e4c396e55b24a079d4f22b33223344bc256c267
Author: Colomban Wendling <ban@herbesfolles.org>
Date:   Wed Apr 23 18:53:22 2014 +0200

    Avoid flickering on some redraws with GTK >= 3.9.2
    
    To avoid abandoning paints, we pre-compute everything that would
    trigger it just before painting, and possibly extending the paint area
    if needed.
    
    Most of the logic is taken from ScintillaCocoa::WillDraw().
    
    FIXME: check with older versions of GTK3 and add/remove version checks
    as needed.

diff --git a/gtk/ScintillaGTK.cxx b/gtk/ScintillaGTK.cxx
index ee0758b..1fa80fd 100644
--- a/gtk/ScintillaGTK.cxx
+++ b/gtk/ScintillaGTK.cxx
@@ -241,6 +241,8 @@ private:
 #endif
 	static void SizeAllocate(GtkWidget *widget, GtkAllocation *allocation);
 #if GTK_CHECK_VERSION(3,0,0)
+	void ResetTextClip(cairo_t *cr);
+	void PrepareDrawText(cairo_t *cr);
 	gboolean DrawTextThis(cairo_t *cr);
 	static gboolean DrawText(GtkWidget *widget, cairo_t *cr, ScintillaGTK *sciThis);
 	gboolean DrawThis(cairo_t *cr);
@@ -2367,11 +2369,55 @@ void ScintillaGTK::Destroy(GObject *object) {
 
 #if GTK_CHECK_VERSION(3,0,0)
 
+// reset the Cairo clip to the whole area of wText
+void ScintillaGTK::ResetTextClip(cairo_t *cr)
+{
+	GdkWindow *win = gtk_widget_get_window(PWidget(wText));
+	PLATFORM_ASSERT(win != NULL);
+	cairo_region_t *r = gdk_window_get_clip_region(win);
+	cairo_rectangle_int_t e;
+	cairo_region_get_extents(r, &e);
+	cairo_region_destroy(r);
+	cairo_reset_clip(cr);
+	cairo_rectangle(cr, e.x, e.y, e.width, e.height);
+	cairo_clip(cr);
+
+	// update the paint area
+	rcPaint.left = e.x;
+	rcPaint.top = e.y;
+	rcPaint.right = e.x + e.width;
+	rcPaint.bottom = e.y + e.height;
+}
+
+void ScintillaGTK::PrepareDrawText(cairo_t *cr)
+{
+	// get the current clip in rcPaint
+	double x1, y1, x2, y2;
+	cairo_clip_extents(cr, &x1, &y1, &x2, &y2);
+	rcPaint.left = x1;
+	rcPaint.top = y1;
+	rcPaint.right = x2;
+	rcPaint.bottom = y2;
+
+	// flush pending updates and pre-compute to avoid abandoning the paint.
+	// taken from ScintillaCocoa::WillDraw()
+	RefreshStyleData();
+	int posAfterRect = PositionAfterArea(rcPaint);
+	pdoc->EnsureStyledTo(posAfterRect);
+	NotifyUpdateUI();
+	if (WrapLines(wsVisible)) {
+		posAfterRect = PositionAfterArea(rcPaint);
+		pdoc->EnsureStyledTo(posAfterRect);
+		// clip probably won't be large enough, so extend it
+		ResetTextClip(cr);
+	}
+}
+
 gboolean ScintillaGTK::DrawTextThis(cairo_t *cr) {
 	try {
-		paintState = painting;
+		PrepareDrawText(cr);
 
-		rcPaint = GetClientRectangle();
+		paintState = painting;
 
 		PLATFORM_ASSERT(rgnUpdate == NULL);
 		rgnUpdate = cairo_copy_clip_rectangle_list(cr);
@@ -2382,12 +2428,6 @@ gboolean ScintillaGTK::DrawTextThis(cairo_t *cr) {
 			rgnUpdate = 0;
 		}
 
-		double x1, y1, x2, y2;
-		cairo_clip_extents(cr, &x1, &y1, &x2, &y2);
-		rcPaint.left = x1;
-		rcPaint.top = y1;
-		rcPaint.right = x2;
-		rcPaint.bottom = y2;
 		PRectangle rcClient = GetClientRectangle();
 		paintingAllText = rcPaint.Contains(rcClient);
 		Surface *surfaceWindow = Surface::Allocate(SC_TECHNOLOGY_DEFAULT);
@@ -2399,6 +2439,7 @@ gboolean ScintillaGTK::DrawTextThis(cairo_t *cr) {
 		}
 		if (paintState == paintAbandoned) {
 			// Painting area was insufficient to cover new styling or brace highlight positions
+			// This should never hit if PrepareDrawText() did its job correctly
 			FullPaint();
 		}
 		paintState = notPainting;
@@ -2425,6 +2466,10 @@ gboolean ScintillaGTK::DrawThis(cairo_t *cr) {
 		    GTK_CONTAINER(PWidget(wMain)), PWidget(scrollbarh), cr);
 		gtk_container_propagate_draw(
 		    GTK_CONTAINER(PWidget(wMain)), PWidget(scrollbarv), cr);
+#if GTK_CHECK_VERSION(3,9,2) /* FIXME: test on older GTK3, test should not be needed */
+		gtk_container_propagate_draw(
+		    GTK_CONTAINER(PWidget(wMain)), PWidget(wText), cr);
+#endif
 	} catch (...) {
 		errorStatus = SC_STATUS_FAILURE;
 	}
